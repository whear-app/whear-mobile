import { useCallback, useEffect, useState } from 'react';
import * as AuthSession from 'expo-auth-session';
import { useNavigation } from '@react-navigation/native';
import { NativeStackNavigationProp } from '@react-navigation/native-stack';

import { ROUTES } from '../constants/routes';
import { AuthStackParamList } from '../navigation/types';
import { useAuthStore } from '../features/authStore';
import { useSnackbar } from './useSnackbar';
import { ENV, assertEnv } from '../config/env';

type NavigationProp = NativeStackNavigationProp<AuthStackParamList>;

type UseGoogleAuthResult = {
  isReady: boolean;
  isLoading: boolean;
  signInWithGoogle: () => Promise<void>;
  authorizationCode: string | null;
  codeVerifier: string | null;
};

// Set to true to use Authorization Code flow instead of Implicit flow
const USE_CODE_FLOW = false;

export function useGoogleAuth(): UseGoogleAuthResult {
  const navigation = useNavigation<NavigationProp>();
  const { loginWithGoogle, isLoading: isAuthStoreLoading } = useAuthStore();
  const { showSnackbar } = useSnackbar();
  const [isProcessing, setIsProcessing] = useState(false);
  const [authorizationCode, setAuthorizationCode] = useState<string | null>(null);
  const [codeVerifier, setCodeVerifier] = useState<string | null>(null);

  // Local redirect (exp://...) generated by Expo Linking
  const localRedirectUri = AuthSession.makeRedirectUri();
  const needsProxy = localRedirectUri.startsWith('exp://');

  // For Expo Go proxy, we need to use the proxy redirect URI
  const proxyRedirectUri = (() => {
    const fullName = ENV.expoProjectFullName;
    return fullName ? `https://auth.expo.io/${fullName}` : '';
  })();

  // Choose the appropriate redirect URI based on the environment
  const redirectUri = needsProxy ? proxyRedirectUri : localRedirectUri;

  const discovery = AuthSession.useAutoDiscovery('https://accounts.google.com');

  // Log redirect URIs for Google Console setup (only in dev)
  useEffect(() => {
    if (__DEV__) {
      console.log(
        `[GOOGLE_AUTH] ==================== SETUP INFO ====================\n` +
        `[GOOGLE_AUTH] Flow: ${USE_CODE_FLOW ? 'Authorization Code (with PKCE)' : 'Implicit'}\n` +
        `[GOOGLE_AUTH] Environment: ${needsProxy ? 'Expo Go (proxy)' : 'Dev build / standalone'}\n` +
        `[GOOGLE_AUTH] redirectUri (add to Google Console): ${redirectUri}\n` +
        `[GOOGLE_AUTH] localRedirectUri: ${localRedirectUri}\n` +
        `[GOOGLE_AUTH] needsProxy: ${String(needsProxy)}\n` +
        `[GOOGLE_AUTH] =====================================================`
      );
    }
  }, [localRedirectUri, redirectUri, needsProxy]);

  const [request, response, promptAsync] = AuthSession.useAuthRequest(
    {
      clientId: ENV.googleWebClientId,
      redirectUri,
      scopes: ['openid', 'profile', 'email'],
      // Choose flow based on configuration
      responseType: USE_CODE_FLOW ? 'code' : 'token',
      // Enable PKCE for code flow, disable for implicit flow
      usePKCE: USE_CODE_FLOW,
    },
    discovery
  );

  // Store code verifier when request is created (for code flow)
  useEffect(() => {
    if (USE_CODE_FLOW && request && (request as any).codeVerifier) {
      const verifier = (request as any).codeVerifier;
      setCodeVerifier(verifier);
      if (__DEV__) {
        console.log('[GOOGLE_AUTH] üîë Code verifier stored (truncated):', `${verifier.slice(0, 12)}...`);
      }
    }
  }, [request]);

  // Validate environment on mount
  useEffect(() => {
    try {
      assertEnv();
    } catch (e) {
      showSnackbar((e as Error).message, 'error');
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  // Exchange authorization code for access token
  const exchangeCodeForToken = async (code: string, verifier: string | null) => {
    if (!discovery?.tokenEndpoint) {
      throw new Error('Token endpoint not available');
    }

    const params = new URLSearchParams({
      client_id: ENV.googleWebClientId,
      code,
      redirect_uri: redirectUri,
      grant_type: 'authorization_code',
    });

    // Add code verifier for PKCE flow
    if (verifier) {
      params.append('code_verifier', verifier);
    }

    const response = await fetch(discovery.tokenEndpoint, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/x-www-form-urlencoded',
      },
      body: params.toString(),
    });

    if (!response.ok) {
      const error = await response.text();
      throw new Error(`Token exchange failed: ${error}`);
    }

    return response.json();
  };

  // Handle auth response from Google
  useEffect(() => {
    const handleAuthResponse = async () => {
      if (!response) return;
      
      if (response.type === 'error') {
        console.error('[GOOGLE_AUTH] ‚ùå Auth error:', response.error);
        showSnackbar(
          response.error?.message || 'Google authentication failed',
          'error'
        );
        setIsProcessing(false);
        return;
      }

      if (response.type === 'cancel') {
        console.log('[GOOGLE_AUTH] ‚ÑπÔ∏è  User cancelled authentication');
        setIsProcessing(false);
        return;
      }

      if (response.type !== 'success') {
        setIsProcessing(false);
        return;
      }

      try {
        setIsProcessing(true);
        assertEnv();

        let accessToken: string;

        // Handle Authorization Code flow
        if (USE_CODE_FLOW && response.params.code) {
          const code = response.params.code;
          setAuthorizationCode(code);
          
          if (__DEV__) {
            console.log('[GOOGLE_AUTH] üîê Authorization code received (truncated):', `${code.slice(0, 12)}...`);
            console.log('[GOOGLE_AUTH] üîÑ Exchanging code for token...');
          }

          // Exchange code for token
          const tokenResponse = await exchangeCodeForToken(code, codeVerifier);
          accessToken = tokenResponse.access_token;

          if (__DEV__) {
            console.log('[GOOGLE_AUTH] ‚úÖ Token exchange successful');
          }
        } 
        // Handle Implicit flow
        else {
          accessToken = response.params.access_token;
          if (!accessToken) {
            throw new Error('Google login failed: no access token in response');
          }
        }

        if (__DEV__) {
          console.log('[GOOGLE_AUTH] ‚úÖ Access token obtained (truncated):', `${accessToken.slice(0, 12)}...`);
        }

        // Fetch user info from Google
        const userInfoResponse = await fetch('https://www.googleapis.com/oauth2/v3/userinfo', {
          headers: { Authorization: `Bearer ${accessToken}` },
        });
        
        if (!userInfoResponse.ok) {
          throw new Error('Failed to fetch Google user info');
        }

        const userInfo = await userInfoResponse.json();

        if (__DEV__) {
          console.log('[GOOGLE_AUTH] ‚úÖ Google userInfo:', {
            sub: userInfo.sub,
            email: userInfo.email,
            name: userInfo.name,
          });
        }

        // Login with Google (this will create/update user in backend)
        await loginWithGoogle({
          id: userInfo.sub,
          email: userInfo.email,
          name: userInfo.name || userInfo.email,
          accessToken,
        });

        if (__DEV__) {
          console.log('[GOOGLE_AUTH] ‚úÖ loginWithGoogle completed successfully');
        }

        // Show success message
        showSnackbar('Successfully signed in with Google', 'success');

        // Navigate to onboarding flow
        navigation.navigate(ROUTES.ONBOARDING_FLOW);

      } catch (error) {
        console.error('[GOOGLE_AUTH] ‚ùå Error processing Google auth:', error);
        showSnackbar((error as Error).message || 'Failed to sign in with Google', 'error');
      } finally {
        setIsProcessing(false);
      }
    };

    handleAuthResponse();
  }, [response, loginWithGoogle, navigation, showSnackbar, codeVerifier]);

  const signInWithGoogle = useCallback(async () => {
    try {
      assertEnv();

      if (!discovery) {
        throw new Error('Google auth is not ready yet (discovery not loaded). Please try again.');
      }

      if (needsProxy && !proxyRedirectUri) {
        throw new Error(
          'Cannot determine AuthSession proxy redirect URI. Set EXPO_PUBLIC_EXPO_PROJECT_FULL_NAME to @owner/slug (e.g. @yourname/whear-v2) and restart Metro with --clear.'
        );
      }

      if (!request) {
        throw new Error(
          'Google auth is not ready yet. Make sure you created a `.env` file (NOT env.example) and restarted Metro with `--clear`.'
        );
      }

      // Debug: Show the redirect URI that will be sent to Google
      if (__DEV__) {
        console.log('[GOOGLE_AUTH] ==================== AUTH START ====================');
        console.log('[GOOGLE_AUTH] Flow:', USE_CODE_FLOW ? 'Authorization Code' : 'Implicit');
        console.log('[GOOGLE_AUTH] needsProxy:', needsProxy);
        console.log('[GOOGLE_AUTH] redirectUri to Google:', redirectUri);
        
        // Parse the auth URL to verify redirect_uri parameter
        const authUrl = (request as any)?.url;
        if (authUrl) {
          try {
            const authUrlObj = new URL(authUrl);
            const redirectUriParam = authUrlObj.searchParams.get('redirect_uri');
            const responseTypeParam = authUrlObj.searchParams.get('response_type');
            console.log('[GOOGLE_AUTH] redirect_uri in request:', redirectUriParam);
            console.log('[GOOGLE_AUTH] response_type in request:', responseTypeParam);
            
            if (redirectUriParam !== redirectUri) {
              console.warn(
                '[GOOGLE_AUTH] ‚ö†Ô∏è  WARNING: redirect_uri mismatch!\n' +
                `Expected: ${redirectUri}\n` +
                `Got: ${redirectUriParam}\n` +
                'Add BOTH to Google Console if needed.'
              );
            } else {
              console.log('[GOOGLE_AUTH] ‚úÖ redirect_uri matches expected value');
            }
          } catch (e) {
            console.warn('[GOOGLE_AUTH] Could not parse authUrl for debugging:', e);
          }
        }
        console.log('[GOOGLE_AUTH] ========================================================');
      }

      // Reset states before new auth attempt
      setAuthorizationCode(null);
      setIsProcessing(true);

      // Trigger the auth flow
      const result = await promptAsync({ showInRecents: true });
      
      // If user cancels or there's an error, reset processing state
      // Success case is handled in the useEffect above
      if (result.type !== 'success') {
        setIsProcessing(false);
      }
      
    } catch (e) {
      console.error('[GOOGLE_AUTH] ‚ùå Error starting Google auth:', e);
      setIsProcessing(false);
      showSnackbar((e as Error).message || 'Failed to start Google authentication', 'error');
    }
  }, [
    promptAsync,
    request,
    showSnackbar,
    discovery,
    needsProxy,
    redirectUri,
    proxyRedirectUri,
  ]);

  // Combine all loading states
  const isLoading = isProcessing || isAuthStoreLoading;

  return {
    isReady: !!request && !!discovery,
    isLoading,
    signInWithGoogle,
    authorizationCode,
    codeVerifier,
  };
}